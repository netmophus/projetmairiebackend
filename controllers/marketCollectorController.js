


const TaxChefMarketPaiement = require('../models/TaxChefMarketPaiement');
const TaxMarketReceiptBatch = require('../models/TaxMarketReceiptBatch');
const MarketCollector = require('../models/MarketCollector');
const mongoose = require('mongoose');
const Market = require('../models/Market');


const moment = require('moment');


exports.payWithTaxReceiptCode = async (req, res) => {
  try {
    const { codeConfirmation, amount } = req.body;
    const userId = req.user.id;

    if (!codeConfirmation || !amount) {
      return res.status(400).json({ message: "Code ou montant manquant." });
    }

    const marketCollector = await MarketCollector.findOne({
      user: userId,
      assignedMarkets: { $exists: true, $not: { $size: 0 } }
    });

    if (!marketCollector) {
      return res.status(403).json({ message: "Non autoris√© : pas de march√© affect√©." });
    }

    const marketId = marketCollector.assignedMarkets[0];

    const batch = await TaxMarketReceiptBatch.findOne({
      market: marketId,
      marketCollector: userId,
      'confirmationCodes.codeConfirmation': codeConfirmation.toUpperCase()
    });

    if (!batch) {
      return res.status(404).json({ message: "Code de confirmation introuvable ou invalide." });
    }

    const codeObj = batch.confirmationCodes.find(
      (c) => c.codeConfirmation === codeConfirmation.toUpperCase()
    );

    if (!codeObj || codeObj.status !== 'Activated') {
      return res.status(400).json({ message: "Re√ßu d√©j√† utilis√© ou non activ√©." });
    }

    const paiement = await TaxChefMarketPaiement.create({
      receiptBatchId: batch._id,
      receiptNumber: codeObj.receiptNumber,
      codeConfirmation: codeObj.codeConfirmation,
      market: marketId,
      marketCollector: userId,
      amount
    });

    codeObj.status = 'Used';
    await batch.save();

    res.status(201).json({
      message: '‚úÖ Paiement valid√©.',
      paiement
    });

  } catch (err) {
    console.error('‚ùå Erreur lors du paiement :', err);
    res.status(500).json({ message: 'Erreur serveur.' });
  }
};




//=======================================================================


// Create a new market collector
exports.createCollector = async (req, res) => {
  try {
    const { name, phone, assignedMarket } = req.body;

    if (!name || !phone || !assignedMarket) {
      return res.status(400).json({ message: 'Nom, t√©l√©phone et march√© assign√© sont requis.' });
    }

    const collector = new MarketCollector({ name, phone, assignedMarket });
    await collector.save();

    res.status(201).json({ message: 'Collecteur ajout√© avec succ√®s.', collector });
  } catch (err) {
    console.error('Erreur lors de la cr√©ation du collecteur:', err.message);
    res.status(500).json({ message: 'Erreur interne du serveur.' });
  }
};

// Get all market collectors
exports.getCollectors = async (req, res) => {
  try {
    const collectors = await MarketCollector.find().populate('assignedMarket', 'name location');
    res.status(200).json(collectors);
  } catch (err) {
    console.error('Erreur lors de la r√©cup√©ration des collecteurs:', err.message);
    res.status(500).json({ message: 'Erreur interne du serveur.' });
  }
};





// controllers/marketCollectorController.js


exports.getMyAssignedMarket = async (req, res) => {
  try {
    // 1Ô∏è‚É£ Log de l'utilisateur connect√©
    console.log('üîê Utilisateur connect√© :', req.user);

    // 2Ô∏è‚É£ Log de tous les MarketCollectors pour comparaison
    const allMC = await MarketCollector.find({});
    console.log('üßæ Tous les MarketCollectors en base :', allMC);

    // 3Ô∏è‚É£ Tentative de r√©cup√©ration du MarketCollector correspondant
    const mc = await MarketCollector
      .findOne({ user: req.user.id })
      .populate('assignedMarkets', 'name location');

    console.log('üîç Recherche avec user ID :', req.user.id);
    console.log('üìå MarketCollector trouv√© :', mc);

    // 4Ô∏è‚É£ V√©rification du contenu
    if (!mc) {
      console.warn('‚ö†Ô∏è Aucun document MarketCollector trouv√© pour cet utilisateur.');
      return res.status(404).json({ message: 'Collecteur non trouv√©.' });
    }

    if (!mc.assignedMarkets || mc.assignedMarkets.length === 0) {
      console.warn('‚ö†Ô∏è Aucun march√© assign√© √† ce collecteur.');
      return res.status(404).json({ message: 'Aucun march√© assign√©.' });
    }

    // 5Ô∏è‚É£ Log du march√© retourn√©
    const market = mc.assignedMarkets[0];
    console.log('‚úÖ March√© assign√© :', market);

    return res.status(200).json({
      name: market.name,
      location: market.location
    });

  } catch (err) {
    console.error('‚ùå Erreur getMyAssignedMarket :', err);
    return res.status(500).json({ message: 'Erreur serveur.' });
  }
};


exports.getAssignedCollectors = async (req, res) => {
  try {
    // 1Ô∏è‚É£ R√©cup√®re le march√© du chefmarket connect√©
    const market = await Market.findOne({ chefmarket: req.user.id });
    if (!market) {
      return res.status(404).json({ message: 'March√© introuvable pour ce chef.' });
    }

    // 2Ô∏è‚É£ Cherche tous les MarketCollector qui ont ce march√© dans assignedMarkets
    const mcs = await MarketCollector
      .find({ assignedMarkets: market._id })
      .populate('user', 'name phone');

    // 3Ô∏è‚É£ On extrait et renvoie la liste des users (collecteurs)
    const collectors = mcs.map(mc => mc.user);
    return res.status(200).json(collectors);
  } catch (err) {
    console.error('Erreur getAssignedCollectors :', err);
    return res.status(500).json({ message: 'Erreur serveur.' });
  }
};


exports.getActiveReceiptPrefix = async (req, res) => {
  const userId = req.user.id;

  const mc = await MarketCollector.findOne({ user: userId });
  if (!mc) return res.status(404).json({ message: "Collecteur non trouv√©." });

  const marketId = mc.assignedMarkets[0];

  const batch = await TaxMarketReceiptBatch.findOne({
    market: marketId,
    marketCollector: userId,
    status: 'Activated'
  });

  if (!batch) return res.status(404).json({ message: "Aucun lot activ√©." });

  const startReceipt = batch.startReceipt; // ex: REC-MRK-2025-00001
  const prefix = startReceipt.slice(0, -5); // enl√®ve les 5 derniers chiffres

  res.status(200).json({ prefix });
};



// exports.getNextAvailableCode = async (req, res) => {
//   try {
//     const userId = req.user.id;
//      console.log('‚úÖ userId re√ßu :', userId);

//     // üîç R√©cup√®re le document MarketCollector associ√© au user connect√©
//     const collector = await MarketCollector.findOne({ user: userId });
//       console.log('üîç R√©sultat MarketCollector :', collector);
//     if (!collector) {
//       return res.status(404).json({ message: 'Collecteur introuvable.' });
//     }

//     // R√©cup√®re les lots de ce collecteur avec status "Activated"
//     const batches = await TaxMarketReceiptBatch.find({
//       marketCollector: userId,
//       status: 'Activated'
//     });

//     // Parcourt les lots pour trouver le premier code activ√© disponible
//     for (const batch of batches) {
//       const codeObj = batch.confirmationCodes.find(c => c.status === 'Activated');
//       if (codeObj) {
//         return res.status(200).json({ code: codeObj.codeConfirmation });
//       }
//     }

//     return res.status(404).json({ message: 'Aucun code disponible.' });
//   } catch (err) {
//     console.error('Erreur getNextAvailableCode :', err);
//     res.status(500).json({ message: 'Erreur serveur.' });
//   }
// };


exports.getNextAvailableCode = async (req, res) => {
  try {
    const userId = req.user.id;
    console.log('‚úÖ userId re√ßu :', userId);

    // üîç R√©cup√©ration du collecteur li√© √† l'utilisateur
    const collector = await MarketCollector.findOne({ user: userId });
    console.log('üîç R√©sultat MarketCollector :', collector);

    if (!collector) {
      return res.status(200).json({ code: null, message: 'Collecteur non trouv√©.' });
    }

    // üéØ R√©cup√®re les lots de re√ßus activ√©s
    const batches = await TaxMarketReceiptBatch.find({
      marketCollector: userId,
      status: 'Activated'
    });

    if (batches.length === 0) {
      return res.status(200).json({
        code: null,
        message: 'Aucun lot de re√ßus activ√© disponible.'
      });
    }

    // üîç Recherche du premier code activ√© disponible
    for (const batch of batches) {
      const codeObj = batch.confirmationCodes.find(c => c.status === 'Activated');
      if (codeObj) {
        return res.status(200).json({ code: codeObj.codeConfirmation });
      }
    }

    // ‚úÖ Aucun code activ√© trouv√© malgr√© des lots actifs
    return res.status(200).json({
      code: null,
      message: 'Tous les codes ont √©t√© utilis√©s.'
    });

  } catch (err) {
    console.error('‚ùå Erreur getNextAvailableCode :', err);
    return res.status(500).json({ message: 'Erreur serveur.' });
  }
};


exports.verifyCollectorReceiptCode = async (req, res) => {
  try {
    const { code } = req.query;
    const collectorId = req.user.id;

    if (!code || code.length !== 6) {
      return res.status(400).json({ message: 'Code invalide.' });
    }

    // üîç Recherche dans les lots activ√©s du collecteur connect√©
    const batch = await TaxMarketReceiptBatch.findOne({
      'confirmationCodes.codeConfirmation': code.toUpperCase()
    })
    .populate('marketCollector', 'name')  // On veut le nom du collecteur
    .populate('market', 'name');           // On veut le nom du march√©

    if (!batch) {
      return res.status(404).json({ message: 'Code introuvable ou non activ√©.' });
    }

    const receipt = batch.confirmationCodes.find(c => c.codeConfirmation === code.toUpperCase());

    if (!receipt || receipt.status !== 'Activated') {
      return res.status(400).json({ message: 'Code d√©j√† utilis√© ou inactif.' });
    }

    return res.status(200).json({
      codeConfirmation: receipt.codeConfirmation,
      receiptNumber: receipt.receiptNumber,
      market: batch.market,
      marketCollector: batch.marketCollector
    });

  } catch (err) {
    console.error('‚ùå Erreur lors de la v√©rification du code :', err);
    res.status(500).json({ message: 'Erreur serveur.' });
  }
};





exports.getMyDailyPayments = async (req, res) => {
  try {
    const collectorId = req.user.id; // ‚úÖ corrig√© ici (venant du token)

    const startOfDay = moment.utc().startOf('day').toDate();
    const endOfDay = moment.utc().endOf('day').toDate();

    console.log('üìå Paiements du collecteur ID :', collectorId);
    console.log('üìÖ Date UTC d√©but :', startOfDay);
    console.log('üìÖ Date UTC fin   :', endOfDay);

    const payments = await TaxChefMarketPaiement.find({
      marketCollector: collectorId,
      createdAt: { $gte: startOfDay, $lte: endOfDay },
    }).sort({ createdAt: -1 });

    res.json(payments);
  } catch (error) {
    console.error('‚ùå Erreur getMyDailyPayments:', error);
    res.status(500).json({ message: 'Erreur serveur' });
  }
};

