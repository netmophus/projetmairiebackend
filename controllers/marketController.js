const Market = require('../models/Market');
const Collector = require('../models/Collector');
const User = require('../models/User');
const MarketCollector = require('../models/MarketCollector');
const { ObjectId } = require('mongodb');

// Create a new market




// Cr√©er un nouveau march√© avec plusieurs collecteurs


exports.createMarket = async (req, res) => {
  try {
    console.log('‚û°Ô∏è D√©but de la cr√©ation du march√©...');
    console.log('üì• Donn√©es re√ßues :', req.body);

    const { name, location, collector } = req.body;

    if (!name || !location || !collector || collector.length === 0) {
      console.error('‚ùå Nom, localisation ou collecteurs manquants');
      return res.status(400).json({ message: 'Nom, localisation et collecteurs sont requis.' });
    }

    // R√©cup√©rer les utilisateurs √† partir des collecteurs
    const existingCollectors = await Collector.find({
      _id: { $in: collector }
    }).populate('user');

    if (existingCollectors.length !== collector.length) {
      console.error('‚ùå Un ou plusieurs collecteurs sont introuvables :', collector);
      return res.status(404).json({ message: 'Un ou plusieurs collecteurs sont introuvables.' });
    }

    console.log('‚úÖ Collecteurs v√©rifi√©s :', existingCollectors);

    // Extraire les ObjectId des User √† partir des collecteurs
    const userIds = existingCollectors.map(collector => collector.user._id);

    // Cr√©er le march√© avec les ObjectId des User
    const market = new Market({
      name,
      location,
      collector: userIds  // Utilisation des ObjectId des User
    });

    await market.save();
    console.log('‚úÖ March√© cr√©√© avec succ√®s :', market);

    // Mettre √† jour MarketCollector pour chaque collecteur
    for (const col of existingCollectors) {
      let marketCollector = await MarketCollector.findOne({ user: col.user._id });

      if (!marketCollector) {
        // Si MarketCollector n'existe pas, en cr√©er un
        marketCollector = new MarketCollector({
          user: col.user._id,
          assignedMarkets: [market._id]
        });
      } else {
        // Sinon, ajouter le march√© √† la liste des march√©s assign√©s
        if (!marketCollector.assignedMarkets.includes(market._id)) {
          marketCollector.assignedMarkets.push(market._id);
        }
      }

      await marketCollector.save();
      console.log('‚úÖ MarketCollector mis √† jour pour le collecteur :', col.user._id);
    }

    res.status(201).json({
      message: 'March√© cr√©√© avec succ√®s et collecteurs mis √† jour.',
      market
    });
  } catch (err) {
    console.error('‚ùå Erreur lors de la cr√©ation du march√© :', err.message);
    res.status(500).json({ message: 'Erreur interne du serveur.' });
  }
};



// Mettre √† jour un march√© pour ajouter ou retirer des collecteurs
exports.updateMarketCollectors = async (req, res) => {
  try {
    const { marketId } = req.params;
    const { collector } = req.body; // Liste des nouveaux collecteurs √† ajouter

    if (!collector || collector.length === 0) {
      return res.status(400).json({ message: "Les collecteurs sont requis." });
    }

    // V√©rifier si le march√© existe et r√©cup√©rer les collecteurs actuels
    const marketToUpdate = await Market.findById(marketId).populate("collector", "_id name phone");
    if (!marketToUpdate) {
      return res.status(404).json({ message: "March√© non trouv√©." });
    }

    console.log("üîÑ Collecteurs existants avant mise √† jour :", marketToUpdate.collector);
    console.log("üì• Nouveaux collecteurs re√ßus :", collector);

    // Fusionner les collecteurs existants et les nouveaux (sans doublons)
    const updatedCollectors = [
      ...new Set([...marketToUpdate.collector.map((c) => c._id.toString()), ...collector]),
    ];

    console.log("‚úÖ Liste finale des collecteurs :", updatedCollectors);

    // Mettre √† jour le march√© avec la nouvelle liste de collecteurs
    const updatedMarket = await Market.findByIdAndUpdate(
      marketId,
      { collector: updatedCollectors },
      { new: true }
    ).populate("collector", "name phone email");

    console.log("‚úÖ Collecteurs mis √† jour avec succ√®s :", updatedMarket.collector);
    res.status(200).json({ message: "Collecteurs mis √† jour.", market: updatedMarket });
  } catch (err) {
    console.error("‚ùå Erreur lors de la mise √† jour des collecteurs :", err.message);
    res.status(500).json({ message: "Erreur interne du serveur." });
  }
};










exports.getMarkets = async (req, res) => {
  try {
    const markets = await Market.find().populate({
      path: 'collector',
      model: 'User',
      select: 'name phone email'  // S√©lectionnez les champs √† afficher
    });

    console.log('‚úÖ March√©s r√©cup√©r√©s avec les collecteurs :', JSON.stringify(markets, null, 2));
    res.status(200).json(markets);
  } catch (error) {
    console.error('‚ùå Erreur lors de la r√©cup√©ration des march√©s :', error.message);
    res.status(500).json({ message: 'Erreur lors de la r√©cup√©ration des march√©s' });
  }
};



// Get all collectors
exports.getCollectors = async (req, res) => {
    try {
      console.log('‚û°Ô∏è D√©but de la r√©cup√©ration des collecteurs...');
      const collectors = await User.find({ role: 'collector' }).select('name phone');
      console.log('‚úÖ Collecteurs r√©cup√©r√©s :', collectors);
      res.status(200).json(collectors);
    } catch (err) {
      console.error('‚ùå Erreur lors de la r√©cup√©ration des collecteurs :', err.message);
      res.status(500).json({ message: 'Erreur interne du serveur.' });
    }
  };
  
  

  
exports.getMarketsByCollector = async (req, res) => {
  try {
    // R√©cup√©rer l'ID du collecteur connect√© depuis le token
    const collectorId = req.user.id;

    console.log("üì• Requ√™te re√ßue pour les march√©s du collecteur :", collectorId);

    // Trouver les march√©s associ√©s √† ce collecteur
    const markets = await Market.find({ collector: collectorId });

    console.log("‚úÖ March√©s r√©cup√©r√©s pour le collecteur :", markets);

    // V√©rifier si des march√©s ont √©t√© trouv√©s
    if (markets.length === 0) {
      return res.status(404).json({ message: "Aucun march√© trouv√© pour ce collecteur." });
    }

    res.status(200).json(markets);
  } catch (err) {
    console.error("‚ùå Erreur lors de la r√©cup√©ration des march√©s :", err.message);
    res.status(500).json({ message: "Erreur interne du serveur." });
  }
};
